AWSTemplateFormatVersion: '2010-09-09'
Description: "Photo Album App - Minimal CloudFormation Template"

Resources:

  # Frontend website bucket
  FrontendBucketCF:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: photo-album-frontend-mlcf
      WebsiteConfiguration:
        IndexDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false

  FrontendBucketPolicyCF:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucketCF
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: "s3:GetObject"
            Resource: !Sub "arn:aws:s3:::${FrontendBucketCF}/*"

  # Storage bucket for photos
  PhotosBucketCF:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: photo-storage-mlcf

  # Lambda IAM role
  LambdaExecutionRoleCF:
    Type: AWS::IAM::Role
    Properties:
      RoleName: photo-album-lambda-rolecf
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AllowS3PhotoAccess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource: !Sub "${PhotosBucketCF.Arn}/*"
            Version: '2012-10-17'

  # Index Lambda
  IndexLambdaCF:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: index-photoscf
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 10
      Role: !GetAtt LambdaExecutionRoleCF.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from opensearchpy import OpenSearch, RequestsHttpConnection
          from requests_aws4auth import AWS4Auth

          rekognition = boto3.client('rekognition', region_name='us-east-1')
          s3 = boto3.client('s3', region_name='us-east-1')

          # ElasticSearch configuration
          ES_HOST = 'search-photos-nl743nwo2u243qlphekwu4pu2y.us-east-1.es.amazonaws.com'
          ES_PORT = 443
          ES_INDEX = 'photos'
          region = 'us-east-1'

          OS_USERNAME = os.environ.get('OS_USERNAME', '')
          OS_PASSWORD = os.environ.get('OS_PASSWORD', '')

          def lambda_handler(event, context):
              print("=== Index Photos Lambda Invoked ===")
              print("Event:", json.dumps(event))

              try:
                  # Get S3 object details from event
                  record = event['Records'][0]
                  bucket = record['s3']['bucket']['name']
                  key = record['s3']['object']['key']
              
                  # decode the key
                  from urllib.parse import unquote_plus
                  key = unquote_plus(key)

                  print("Decoded key:", key)
                  # print("Does object exist?")
                  # try:
                  #     s3.head_object(Bucket=bucket, Key=key)
                  #     print("Object exists")
                  # except:
                  #     print("Object NOT found!")
                  print("DEBUG: checking object existence")
                  try:
                      obj = s3.get_object(Bucket=bucket, Key=key)
                      print("DEBUG: object retrieved, size =", obj['ContentLength'])
                  except Exception as e:
                      print("DEBUG ERROR: cannot retrieve object:", e)

                  print(f"Processing Image: s3://{bucket}/{key}")

                  # Get S3 metadata
                  print("Getting S3 metadata...")
                  head_response = s3.head_object(Bucket=bucket, Key=key)
                  print("DEBUG: Content-Type =", head_response['ContentType'])
                  print("DEBUG: File size:", head_response['ContentLength'])
                  metadata = head_response.get('Metadata', {})
                  
                  # Extract custom labels
                  print("Extracting custom labels from S3 metadata...")
                  custom_labels = metadata.get('customlabels', '')
                  print("Custom labels:", custom_labels)

                  # Detect labels using Rekognition
                  print("Detecting labels using Rekognition...")
                  rekognition_response = rekognition.detect_labels(
                      Image={
                          'S3Object': {
                              'Bucket': bucket,
                              'Name': key
                          }
                      },
                      MaxLabels=10,
                      MinConfidence=75
                  )
                  print("Rekognition response:", json.dumps(rekognition_response))
              
                  # Extract labels
                  labels = [label['Name'].lower() for label in rekognition_response['Labels']]
                  print("Detected labels:", labels)

                  if custom_labels:
                      custom_labels_list = [label.strip().lower() for label in custom_labels.split(',')]
                      labels.extend(custom_labels_list)
                      print("Combined labels:", labels)
              
                  # Create JSON object
                  photo_doc = {
                      'objectKey': key,
                      'bucket': bucket,
                      'createdTimestamp': datetime.now().isoformat(),
                      'labels': labels
                  }

                  print("Photo document:", json.dumps(photo_doc))
              
                  
                # Index to OpenSearch
                  print("=== Starting OpenSearch indexing ===")
                  print("Creating OpenSearch client...")
                  es = get_es_client()
                  print("OpenSearch client created successfully")
                  
                  print(f"Indexing to index: {ES_INDEX}, doc ID: {key}")
                  response = es.index(
                      index=ES_INDEX, 
                      body=photo_doc, 
                      id=key,
                      refresh=True
                  )
                  print("=== OpenSearch indexing completed ===")
                  print("OpenSearch response:", json.dumps(response, default=str))
                  
                  # Verify document was indexed
                  print("Verifying document was indexed...")
                  verify_response = es.get(index=ES_INDEX, id=key)
                  print("Verification response:", json.dumps(verify_response, default=str))

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Photo indexed successfully',
                          'objectKey': key,
                          'labels': labels
                      })
                  }
              
              # End
              except Exception as e:
                  print("Error:", e)
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': 'Failed to index photo',
                          'error': str(e)
                      })
                  }

          def get_es_client():
              credentials = boto3.Session().get_credentials()
              awsauth = AWS4Auth(
                  credentials.access_key, 
                  credentials.secret_key,
                  region, 
                  'es',
                  session_token=credentials.token
              )
              
              es = OpenSearch(
                  hosts=[{'host': ES_HOST, 'port': ES_PORT}],
                  http_auth=(OS_USERNAME, OS_PASSWORD),
                  use_ssl=True,
                  verify_certs=True,
                  connection_class=RequestsHttpConnection,
                  timeout=30
              )

              return es

  # Search Lambda
  SearchLambdaCF:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: search-photoscf
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 10
      Role: !GetAtt LambdaExecutionRoleCF.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from opensearchpy import OpenSearch, RequestsHttpConnection
          from requests_aws4auth import AWS4Auth

          lex_client = boto3.client('lexv2-runtime', region_name='us-east-1')
          s3 = boto3.client('s3', region_name='us-east-1')

          ES_HOST = 'search-photos-nl743nwo2u243qlphekwu4pu2y.us-east-1.es.amazonaws.com'
          ES_PORT = 443
          ES_INDEX = 'photos'

          region = 'us-east-1'

          OS_USERNAME = os.environ.get('OS_USERNAME', '')
          OS_PASSWORD = os.environ.get('OS_PASSWORD', '')

          LEX_BOT_ID = os.environ.get('LEX_BOT_ID', '')
          LEX_BOT_ALIAS_ID = os.environ.get('LEX_BOT_ALIAS_ID', '')
          LEX_LOCALE_ID = os.environ.get('LEX_LOCALE_ID', 'en_US')

          def lambda_handler(event, context):
              print("=== Search Lambda Invoked ===")
              print("Event received:", json.dumps(event))

              # Extract query from API Gateway event
              # query = event.get('queryStringParameters', {}).get('q', '')
              query_params = event.get('queryStringParameters') or {}
              query = query_params.get('q', '').strip()

              print(f"Search query: {query}")

              # Validate query
              if not query:
                  return create_response([], "No query provided")
              
              try:
                  # Call Lex
                  lex_response = lex_client.recognize_text(
                      botId=LEX_BOT_ID,
                      botAliasId=LEX_BOT_ALIAS_ID,
                      localeId=LEX_LOCALE_ID,
                      sessionId='test-session',
                      text=query
                  )
                  print(f"Lex response: {lex_response}")

              except Exception as e:
                  print(f"Error calling Lex: {e}")
                  # return create_response([], f"Error calling Lex: {e}")

                  # fallback to direct parsing for keywords
                  lex_response = {}
              

              # Extract keywords
              keywords = []
              stopwords = ['show', 'me', 'photos', 'images', 'pictures', 'of', 'with', 'find', 'search', 'for', 'and']

              if 'sessionState' in lex_response:
                  slots = lex_response.get('sessionState', {}).get('intent', {}).get('slots', {})

                  if slots and 'labels' in slots and slots['labels']:
                      label_value = slots['labels'].get('value', {}).get('originalValue', '')
                      # check if labels2 value exists
                      if 'labels2' in slots and slots['labels2']:
                          label_value += ' ' + slots['labels2'].get('value', {}).get('originalValue', '')
                      # extract keywords
                      keywords = [k.strip().lower() for k in label_value.split() 
                                          if k.strip() and k.strip() not in stopwords]
              
              print(f"Lex extracted keywords: {keywords}")

              # Fallback: parse query directly for keywords
              if not keywords:
                  print("Lex failed to extract keywords. Falling back to parsing query for keywords....")
                  keywords = [k.strip().lower() for k in query.split() 
                            if k.strip().lower() not in stopwords]
              
              print(f"Final keywords: {keywords}")
              
              if not keywords:
                  return create_response([], f"No keywords found in query: {query}")

              # mock_results = []
              # if keywords:
              #     mock_results = [{
              #         'message': f'Lex bot successfully extracted keywords: {", ".join(keywords)}',
              #         'query': query,
              #         'keywords': keywords,
              #         'note': 'ElasticSearch not configured yet - these are the keywords that would be searched'
              #     }]
              
              # return create_response(mock_results, f"Found {len(keywords)} keywords from query")


              # ########################################################

              # Search ElasticSearch
              try:
                  es = get_es_client()
              
                  # Build query
                  es_query = {
                      'size': 100,
                      'query': {
                          'bool': {
                              'should': [
                                  {'match': {'labels': keyword}} for keyword in keywords
                              ],
                              'minimum_should_match': 1
                          }
                      }
                  }
                  print(f"Opensearch query: {es_query}")
              
                  # Execute query
                  response = es.search(index=ES_INDEX, body=es_query)
                  print(f"Opensearch response: {json.dumps(response, default = str)}")
              
              
                  # Format results
                  results = []
                  for hit in response['hits']['hits']:
                      source = hit['_source']
                      bucket = source['bucket']
                      key = source['objectKey']

                      image_url = f"https://{bucket}.s3.amazonaws.com/{key}"
                      
                      results.append({
                          'url': image_url,
                          'labels': source['labels'],
                          'objectKey': key,
                          'bucket': bucket,
                          'createdTimestamp': source['createdTimestamp']
                      })

                  print(f"Returning {len(results)} results")

                  return create_response(results, f"Found {len(results)} photos matching keywords: {','.join(keywords)}")

              except Exception as e:
                  print(f"Error searching OpenSearch: {e}")
                  return create_response([], f"Error searching OpenSearch: {e}")
              

          def get_es_client():
              credentials = boto3.Session().get_credentials()
              awsauth = AWS4Auth(
                  credentials.access_key, 
                  credentials.secret_key,
                  region, 
                  'es', 
                  session_token=credentials.token
                  )
              
              es = OpenSearch(
                  hosts=[{'host': ES_HOST, 'port': ES_PORT}],
                  http_auth=(OS_USERNAME, OS_PASSWORD),
                  use_ssl=True,
                  verify_certs=True,
                  connection_class=RequestsHttpConnection,
                  timeout=30
              )
              return es

          def create_response(results, message=""):
              return {
                  'statusCode': 200,
                  'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                      'Access-Control-Allow-Methods': 'GET,OPTIONS',
                      'Content-Type': 'application/json'
                  },
                  'body': json.dumps({
                      'results': results,
                      'message': message
                  })
              }

  # API Gateway
  PhotoAPICF:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: photo-album-api-cf

  # upload endpoint
  UploadResourceCF:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PhotoAPICF
      ParentId: !GetAtt PhotoAPICF.RootResourceId
      PathPart: upload

  UploadMethodCF:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PhotoAPICF
      ResourceId: !Ref UploadResourceCF
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${IndexLambdaCF.Arn}/invocations

  # search endpoint
  SearchResourceCF:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PhotoAPICF
      ParentId: !GetAtt PhotoAPICF.RootResourceId
      PathPart: search

  SearchMethodCF:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PhotoAPICF
      ResourceId: !Ref SearchResourceCF
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SearchLambdaCF.Arn}/invocations

  # Permissions for API â†’ Lambda
  LambdaPerm1CF:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref IndexLambdaCF
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com

  LambdaPerm2CF:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SearchLambdaCF
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com

  # Deploy the API
  APIDeploymentCF:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - UploadMethodCF
      - SearchMethodCF
    Properties:
      RestApiId: !Ref PhotoAPICF
      StageName: prod

Outputs:
  FrontendURL:
    Description: "Public website URL"
    Value: !Sub "http://${FrontendBucketCF}.s3-website-${AWS::Region}.amazonaws.com"
  PhotosBucketName:
    Description: "Photo bucket Name"
    Value: !Ref PhotosBucketCF
  APIEndpoint:
    Description: "Full API Gateway Invoke URL"
    Value: !Sub "https://${PhotoAPICF}.execute-api.${AWS::Region}.amazonaws.com/prod"
